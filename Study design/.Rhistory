#
# #stack_farmers <- subset(stack_farmers, !is.na(inputuse_binary))
# #stack_farmers <- subset(stack_farmers, !is.na(seedquality_binary))
#
# possible.ns <- seq(from=100, to=2000, by=100) # The sample sizes we'll be considering
# powers <- rep(NA, length(possible.ns))           # Empty object to collect simulation estimates
# alpha <- 0.05                                    # Standard significance level
# sims <- 100                                      # Number of simulations to conduct for each N
#
# #### Outer loop to vary the number of subjects ####
# for (j in 1:length(possible.ns)){
#   N <- possible.ns[j]                              # Pick the jth value for N
#
#   significant.experiments <- rep(NA, 100)         # Empty object to count significant experiments
#
#   #### Inner loop to conduct experiments "sims" times over for each N ####
#   for (i in 1:sims){             # control potential outcome
#     #sample_dta <- stack_farmers[c("id.agro","yield_kg_per_acre")][sample(nrow(stack_farmers), size = N, replace = TRUE),]             # control potential outcome - is now a data frame with 2 vars
#     sample_dta <- stack_farmers[c("agro_catchID","yield_kg_per_acre")][sample(nrow(stack_farmers), size = N, replace = TRUE),]             # control potential outcome - is now a data frame with 2 vars
#     names(sample_dta) <- c("cluster_ID","Y0")
#     tau <- 81.04422                           # Hypothesize treatment effect
#     sample_dta$Y1 <- sample_dta$Y0 + tau                                 # treatment potential outcome
#     #randomize(stack_farmers, group = c("1", "0"), block = stack_farmers$id_inputdealer)
#     #Z.sim <- rbinom(n=N, size=1, prob=.5)          # Do a random assignment
#     #Z.sim <- cluster_ra(clusters = stack_farmers$id_inputdealer)
#     sample_dta$Z.sim <- cluster_ra(clusters = sample_dta$cluster_ID)
#     sample_dta$Y.sim <- sample_dta$Y1*sample_dta$Z.sim + sample_dta$Y0*(1-sample_dta$Z.sim)               # Reveal outcomes according to assignment
#     fit.sim <- lm(Y.sim ~ Z.sim, data= sample_dta)                   # Do analysis (Simple regression)
#     p.value <- summary(fit.sim)$coefficients[2,4]  # Extract p-values
#     significant.experiments[i] <- (p.value <= alpha) # Determine significance according to p <= 0.05
#   }
#
#   powers[j] <- mean(significant.experiments)       # store average success rate (power) for each N
# }
# plot(possible.ns, powers, ylim=c(0,1))
# cbind(possible.ns, powers)
#
#how many farmers per input dealer?
# stack_farmers <- subset(stack_farmers, !is.na(id.agro))
# stack_farmers <- subset(stack_farmers, !is.na(yield_kg_per_acre))
#
# stack_dealers$assignment <- rbinom(n=78, size=1, prob=.5)
#
# stack_both <- merge(stack_farmers,stack_dealers,by="id.agro")
#1st attempt:
# stratified <- function(df, group, size, select = NULL,
#                        replace = FALSE, bothSets = FALSE) {
#   if (is.null(select)) {
#     df <- df
#   } else {
#     if (is.null(names(select))) stop("'select' must be a named list")
#     if (!all(names(select) %in% names(df)))
#       stop("Please verify your 'select' argument")
#     temp <- sapply(names(select),
#                    function(x) df[[x]] %in% select[[x]])
#     df <- df[rowSums(temp) == length(select), ]
#   }
#   df.interaction <- interaction(df[group], drop = TRUE)
#   df.table <- table(df.interaction)
#   df.split <- split(df, df.interaction)
#   if (length(size) > 1) {
#     if (length(size) != length(df.split))
#       stop("Number of groups is ", length(df.split),
#            " but number of sizes supplied is ", length(size))
#     if (is.null(names(size))) {
#       n <- setNames(size, names(df.split))
#       message(sQuote("size"), " vector entered as:\n\nsize = structure(c(",
#               paste(n, collapse = ", "), "),\n.Names = c(",
#               paste(shQuote(names(n)), collapse = ", "), ")) \n\n")
#     } else {
#       ifelse(all(names(size) %in% names(df.split)),
#              n <- size[names(df.split)],
#              stop("Named vector supplied with names ",
#                   paste(names(size), collapse = ", "),
#                   "\n but the names for the group levels are ",
#                   paste(names(df.split), collapse = ", ")))
#     }
#   } else if (size < 1) {
#     n <- round(df.table * size, digits = 0)
#   } else if (size >= 1) {
#     if (all(df.table >= size) || isTRUE(replace)) {
#       n <- setNames(rep(size, length.out = length(df.split)),
#                     names(df.split))
#     } else {
#       message(
#         "Some groups\n---",
#         paste(names(df.table[df.table < size]), collapse = ", "),
#         "---\ncontain fewer observations",
#         " than desired number of samples.\n",
#         "All observations have been returned from those groups.")
#       n <- c(sapply(df.table[df.table >= size], function(x) x = size),
#              df.table[df.table < size])
#     }
#   }
#   temp <- lapply(
#     names(df.split),
#     function(x) df.split[[x]][sample(df.table[x],
#                                      n[x], replace = replace), ])
#   set1 <- do.call("rbind", temp)
#
#   if (isTRUE(bothSets)) {
#     set2 <- df[!rownames(df) %in% rownames(set1), ]
#     list(SET1 = set1, SET2 = set2)
#   } else {
#     set1
#   }
# }
#
# stratified(stack_both, "id.agro", 1, replace = TRUE)
#2nd attempt:
# ddply(stack_both,.(id.agro),function(x) x[sample(nrow(x),1),])
#3rd attempt:
# do.call(rbind,
#         lapply(split(stack_both, stack_both$id.agro),
#                function(x) x[sample(nrow(x), 1), ]))
#4th attempt:
# x <- strata(stack_both, "id.agro", size = c(1, 1, 1), method = "srswor")
# getdata(stack_both, x)
#5th attempt:
# new_stack_both <- stack_both[, .SD[sample(x = .N, size = 1)], by="id.agro"]
#6th attempt:
#stack_farmers <- subset(stack_farmers, !is.na(id.agro))
#1: take a sample of size 100, with replacement, from stack_dealers
#sample_dealers <- stack_dealers[sample(nrow(stack_dealers), size = 100, replace = TRUE),]
#2: loop over different dealers in sample_dealers & sample from stack_farmers
# clusters1 <- stack_farmers[1,] #start with something to past to to use rbind (here: first row of stack_farmers), then past samples at the bottom
# for (i in sample_dealers$id.agro) {
#   temp <- stack_farmers[stack_farmers$id.agro == i,]
#   temp <- temp[sample(nrow(temp), size=5, replace = TRUE),]
#   clusters1 <- rbind(clusters1,temp) #need to stack them on top of each other using rbind (rowbind)
# }
#
# clusters1 <- clusters1[2:dim(clusters1)[1],] #remove that first row
#number of obs. changes because different dealers and sampled
#why does clusters1 have e.g. 460 obs and not 100*5=500?
#because AS017, 19, 27, 51, 52, 58, 62, 76 aren't assigned to any farmer: 8*5=40
# #alternative
#
# #stack_farmers <- subset(stack_farmers, !is.na(id.agro))
# #stack_farmers <- subset(stack_farmers, !is.na(yield_kg_per_acre))
# #stack_dealers$assignment <- rbinom(n=78, size=1, prob=.5)
#
# stack_both <- merge(stack_farmers,stack_dealers[sample(nrow(stack_dealers), size = 100000, replace = TRUE),],by="id.agro")
#
# #same as:
# #stack_both <- merge(stack_farmers,stack_dealers,by="id.agro")
# #stack_both <- stack_both[sample(nrow(stack_both), size = 100000, replace = TRUE),]
#
# clusters2 <- do.call(rbind, lapply(split(stack_both, stack_both$id.agro), function(x) x[sample(nrow(x), 5, replace = TRUE), ]))
#
# #only e.g. 250 obs. because many input dealer not in stack_both sample (here: 28 not in sample) even if size = 100 000 (with size = large number: 350 obs because 78*5-8*5)
######################################################
########Power analysis for the standard design########
#######Y0 not normal distribution but real data#######
#################cluster randomization################
######################################################
#interventions & randomization at the level of the catchment area = level of the input dealer (ID) = level of the cluster
stack_farmers$agro_catchID <- as.character(stack_farmers$agro_catchID)
stack_farmers$id.agro <- stack_farmers$agro_catchID #clusters by means of GPS
possible.ns <- 265
possible.fs <- seq(from=1, to=25, by=1)
powers <- rep(NA, length(possible.ns))
alpha <- 0.05
sims <- 500
stack_farmers <- subset(stack_farmers, !is.na(id.agro))
# #yield_kg_per_acre
#
# stack_farmers_yield_kg_per_acre <- subset(stack_farmers, !is.na(yield_kg_per_acre))
# stack_dealers <- subset(stack_dealers, id.agro %in% names(table(stack_farmers_yield_kg_per_acre$id.agro))) #deletes dealers that are not attached to any households
# cl <- makeCluster(detectCores(all.tests = FALSE, logical = TRUE))
# registerDoParallel(cl)
# #1st loop
# for (j in 1:length(possible.ns)){
#   N <- possible.ns[j]
#   print(possible.ns[j]) #print something to show that we are still making progress
#
#   #2nd loop
#   for (f in 1:length(possible.fs)){
#     F <- possible.fs[f]
#     print(possible.fs[f]) #print something to show that we are still making progress
#
#     #3rd loop
#     #  for (i in 1:sims){
#     significant.experiments <- foreach(i = 1:sims,.combine=rbind,.packages=c("doParallel")) %dopar% {
#     sample_dealers <- stack_dealers[sample(nrow(stack_dealers), size = N, replace = TRUE),]
#     sample_dealers$assignment <- rbinom(n=nrow(sample_dealers) , size=1, prob=.5) #do random assignment after you take sample at dealer level
#
#       #4th loop
#       clusters1 <- foreach(k = 1:length(sample_dealers$id.agro),.combine=rbind) %dopar% {
#       #   for (k in 1:length(sample_dealers$id.agro)) {
#       id <- sample_dealers$id.agro[k]
#       temp <- stack_farmers_yield_kg_per_acre[stack_farmers_yield_kg_per_acre$id.agro == id,]
#       temp <- temp[sample(nrow(temp), size=F, replace = TRUE),]
#
#       clusters1 <- return(cbind(temp,sample_dealers$assignment[k]))  #here we get the treatment in again
#       #   <- rbind(clusters1,temp) #need to stack them on top of each other using rbind (rowbind)
#     }
#
#     names(clusters1)[names(clusters1) == 'sample_dealers$assignment[k]'] <- 'assignment'
#
#     clusters1$Y0 <- clusters1$yield_kg_per_acre
#     tau <- 56.91028
#     clusters1$Y1 <- clusters1$Y0 + tau
#     clusters1$Y.sim <- clusters1$Y1*clusters1$assignment + clusters1$Y0*(1-clusters1$assignment)
#     fit.sim <- lm(Y.sim ~ clusters1$assignment, data=clusters1)
#     p.value <- summary(fit.sim)$coefficients[2,4]
#     significant.experiments <- (p.value <= alpha)
#   }
#
#   powers[f] <- mean(significant.experiments)
#   }
#
# }
#
#
# cbind(possible.fs, powers)
# df <- cbind(possible.fs, powers)
# write.csv(df,(paste(path,"Study design/power_yield_kg_per_acre.csv", sep ="/")), row.names = FALSE)
#
df <- read.csv(paste(path,"Study design/power_yield_kg_per_acre.csv", sep ="/"))
png((paste(path,"Study design/power_yield_kg_per_acre.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.fs, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=F)+ labs(y="power", x = "number of farmers per input dealer") + ylim(0, 1) + annotate(geom="text", x=5, y=0.775, label="target power value of 0.8", color="red")
dev.off()
#
# #inputuse_binary
#
# stack_farmers_inputuse_binary <- subset(stack_farmers, !is.na(inputuse_binary))
# stack_dealers <- subset(stack_dealers, id.agro %in% names(table(stack_farmers_inputuse_binary$id.agro))) #deletes dealers that are not attached to any households
# cl <- makeCluster(detectCores(all.tests = FALSE, logical = TRUE))
# registerDoParallel(cl)
# #1st loop
# for (j in 1:length(possible.ns)){
#   N <- possible.ns[j]
#   print(possible.ns[j]) #print something to show that we are still making progress
#
#   #2nd loop
#   for (f in 1:length(possible.fs)){
#     F <- possible.fs[f]
#     print(possible.fs[f]) #print something to show that we are still making progress
#
#     #3rd loop
#     #  for (i in 1:sims){
#     significant.experiments <- foreach(i = 1:sims,.combine=rbind,.packages=c("doParallel")) %dopar% {
#       sample_dealers <- stack_dealers[sample(nrow(stack_dealers), size = N, replace = TRUE),]
#       sample_dealers$assignment <- rbinom(n=nrow(sample_dealers) , size=1, prob=.5) #do random assignment after you take sample at dealer level
#
#       #4th loop
#       clusters1 <- foreach(k = 1:length(sample_dealers$id.agro),.combine=rbind) %dopar% {
#         #   for (k in 1:length(sample_dealers$id.agro)) {
#         id <- sample_dealers$id.agro[k]
#         temp <- stack_farmers_inputuse_binary[stack_farmers_inputuse_binary$id.agro == id,]
#         temp <- temp[sample(nrow(temp), size=F, replace = TRUE),]
#
#         clusters1 <- return(cbind(temp,sample_dealers$assignment[k]))  #here we get the treatment in again
#         #   <- rbind(clusters1,temp) #need to stack them on top of each other using rbind (rowbind)
#       }
#
#       names(clusters1)[names(clusters1) == 'sample_dealers$assignment[k]'] <- 'assignment'
#
#       clusters1$Y0 <- clusters1$inputuse_binary
#       tau <- 0.065
#       clusters1$Y1 <- clusters1$Y0 + tau
#       clusters1$Y.sim <- clusters1$Y1*clusters1$assignment + clusters1$Y0*(1-clusters1$assignment)
#       fit.sim <- lm(Y.sim ~ clusters1$assignment, data=clusters1)
#       p.value <- summary(fit.sim)$coefficients[2,4]
#       significant.experiments <- (p.value <= alpha)
#     }
#
#     powers[f] <- mean(significant.experiments)
#   }
#
# }
#
#
# cbind(possible.fs, powers)
# df <- cbind(possible.fs, powers)
# write.csv(df,(paste(path,"Study design/power_inputuse_binary.csv", sep ="/")), row.names = FALSE)
#
df <- read.csv(paste(path,"Study design/power_inputuse_binary.csv", sep ="/"))
png((paste(path,"Study design/power_inputuse_binary.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.fs, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=F) + labs(y="power", x = "number of farmers per input dealer") + ylim(0, 1) + annotate(geom="text", x=16, y=0.775, label="target power value of 0.8", color="red")
dev.off()
#seedquality_binary
stack_farmers_seedquality_binary <- subset(stack_farmers, !is.na(seedquality_binary))
stack_dealers <- subset(stack_dealers, id.agro %in% names(table(stack_farmers_seedquality_binary$id.agro))) #deletes dealers that are not attached to any households
cl <- makeCluster(detectCores(all.tests = FALSE, logical = TRUE))
registerDoParallel(cl)
# #1st loop
# for (j in 1:length(possible.ns)){
#   N <- possible.ns[j]
#   print(possible.ns[j]) #print something to show that we are still making progress
#
#   #2nd loop
#   for (f in 1:length(possible.fs)){
#     F <- possible.fs[f]
#     print(possible.fs[f]) #print something to show that we are still making progress
#
#     #3rd loop
#     #  for (i in 1:sims){
#     significant.experiments <- foreach(i = 1:sims,.combine=rbind,.packages=c("doParallel")) %dopar% {
#       sample_dealers <- stack_dealers[sample(nrow(stack_dealers), size = N, replace = TRUE),]
#       sample_dealers$assignment <- rbinom(n=nrow(sample_dealers) , size=1, prob=.5) #do random assignment after you take sample at dealer level
#
#       #4th loop
#       clusters1 <- foreach(k = 1:length(sample_dealers$id.agro),.combine=rbind) %dopar% {
#         #   for (k in 1:length(sample_dealers$id.agro)) {
#         id <- sample_dealers$id.agro[k]
#         temp <- stack_farmers_seedquality_binary[stack_farmers_seedquality_binary$id.agro == id,]
#         temp <- temp[sample(nrow(temp), size=F, replace = TRUE),]
#
#         clusters1 <- return(cbind(temp,sample_dealers$assignment[k]))  #here we get the treatment in again
#         #   <- rbind(clusters1,temp) #need to stack them on top of each other using rbind (rowbind)
#       }
#
#       names(clusters1)[names(clusters1) == 'sample_dealers$assignment[k]'] <- 'assignment'
#
#       clusters1$Y0 <- clusters1$seedquality_binary
#       tau <- 0.0887512
#       clusters1$Y1 <- clusters1$Y0 + tau
#       clusters1$Y.sim <- clusters1$Y1*clusters1$assignment + clusters1$Y0*(1-clusters1$assignment)
#       fit.sim <- lm(Y.sim ~ clusters1$assignment, data=clusters1)
#       p.value <- summary(fit.sim)$coefficients[2,4]
#       significant.experiments <- (p.value <= alpha)
#     }
#
#     powers[f] <- mean(significant.experiments)
#   }
#
# }
#
#
# cbind(possible.fs, powers)
# df <- cbind(possible.fs, powers)
# write.csv(df,(paste(path,"Study design/power_seedquality_binary.csv", sep ="/")), row.names = FALSE)
df <- read.csv(paste(path,"Study design/power_seedquality_binary.csv", sep ="/"))
png((paste(path,"Study design/power_seedquality_binary.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.fs, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=F) + labs(y="power", x = "number of farmers per input dealer") + ylim(0, 1) + annotate(geom="text", x=10, y=0.775, label="target power value of 0.8", color="red")
dev.off()
df <- read.csv(paste(path,"Study design/power_quantitysold.csv", sep ="/"))
png((paste(path,"Study design/power_quantitysold.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.ns, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=F)+ labs(y="power", x = "number of input dealers") + xlim(0, 300)+ ylim(0, 1) + annotate(geom="text", x=50, y=0.775, label="target power value of 0.8", color="red")
dev.off()
df <- read.csv(paste(path,"Study design/power_quantitysold.csv", sep ="/"))
png((paste(path,"Study design/power_quantitysold.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.ns, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=F)+ labs(y="power", x = "number of input dealers") + xlim(0, 300)+ ylim(0, 1) + annotate(geom="text", x=75, y=0.775, label="target power value of 0.8", color="red")
dev.off()
df <- read.csv(paste(path,"Study design/power_reputation_av_farmers.csv", sep ="/"))
png((paste(path,"Study design/power_reputation_av_farmers.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.ns, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=F)+ labs(y="power", x = "number of input dealers") + xlim(0, 300)+ ylim(0, 1) + annotate(geom="text", x=75, y=0.775, label="target power value of 0.8", color="red")
dev.off()
df <- read.csv(paste(path,"Study design/power_seedquality_binary.csv", sep ="/"))
png((paste(path,"Study design/power_seedquality_binary.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.fs, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=FALSE) + labs(y="power", x = "number of farmers per input dealer") + ylim(0, 1) + annotate(geom="text", x=10, y=0.775, label="target power value of 0.8", color="red")
dev.off()
df <- read.csv(paste(path,"Study design/power_inputuse_binary.csv", sep ="/"))
png((paste(path,"Study design/power_inputuse_binary.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.fs, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=FALSE) + labs(y="power", x = "number of farmers per input dealer") + ylim(0, 1) + annotate(geom="text", x=16, y=0.775, label="target power value of 0.8", color="red")
dev.off()
df <- read.csv(paste(path,"Study design/power_yield_kg_per_acre.csv", sep ="/"))
png((paste(path,"Study design/power_yield_kg_per_acre.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.fs, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=FALSE)+ labs(y="power", x = "number of farmers per input dealer") + ylim(0, 1) + annotate(geom="text", x=5, y=0.775, label="target power value of 0.8", color="red")
dev.off()
library(ggplot2)
df <- read.csv(paste(path,"Study design/power_quantitysold.csv", sep ="/"))
png((paste(path,"Study design/power_quantitysold.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.ns, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=FALSE)+ labs(y="power", x = "number of input dealers") + xlim(0, 300)+ ylim(0, 1) + annotate(geom="text", x=75, y=0.775, label="target power value of 0.8", color="red")
dev.off()
library(ggplot2)
df <- read.csv(paste(path,"Study design/power_reputation_av_farmers.csv", sep ="/"))
png((paste(path,"Study design/power_reputation_av_farmers.png", sep ="/")), units="px", height=3200, width= 3200, res=600)
#ggplot(df, aes(x = possible.ns, y = powers)) + geom_line() + geom_hline(yintercept = .8, colour =  "red", size=1)
ggplot(df, aes(x = possible.ns, y = powers)) + geom_hline(yintercept = .8, colour =  "red", size=1) + geom_smooth(se=FALSE)+ labs(y="power", x = "number of input dealers") + xlim(0, 300)+ ylim(0, 1) + annotate(geom="text", x=75, y=0.775, label="target power value of 0.8", color="red")
dev.off()
rm(list=ls())
#install.packages("randomizr")
#install.packages("fabricatr")
#install.packages("data.table")
#install.packages("mvnfast")
#install.packages("plyr")
#install.packages("sampling")
#install.packages("devtools")
#install.packages("usethis")
library(randomizr)    #randomizr package for complete random assignment
library(fabricatr)
library(data.table)
library(mvnfast)
library(plyr)
library(sampling)
library(usethis)
library(devtools)
library(doParallel)
library(ggplot2)
### this is executed in the /report subdirectory, need to ..
path <- strsplit(getwd(), "/Study design")[[1]]
stack_dealers <- read.csv(paste(path,"stack surveys/data/agro_input_dealers.csv", sep ="/"))
stack_farmers <- read.csv(paste(path,"stack surveys/data/farmers.csv", sep ="/"))
View(stack_farmers)
View(stack_farmers)
rm(list=ls())
#install.packages("randomizr")
#install.packages("fabricatr")
#install.packages("data.table")
#install.packages("mvnfast")
#install.packages("plyr")
#install.packages("sampling")
#install.packages("devtools")
#install.packages("usethis")
library(randomizr)    #randomizr package for complete random assignment
library(fabricatr)
library(data.table)
library(mvnfast)
library(plyr)
library(sampling)
library(usethis)
library(devtools)
library(doParallel)
library(ggplot2)
### this is executed in the /report subdirectory, need to ..
path <- strsplit(getwd(), "/Study design")[[1]]
stack_dealers <- read.csv(paste(path,"stack surveys/data/agro_input_dealers.csv", sep ="/"))
stack_farmers <- read.csv(paste(path,"stack surveys/data/farmers.csv", sep ="/"))
###YIELD###
#transform
stack_farmers$hh.maize.maizen.q64[stack_farmers$hh.maize.maizen.q64==999] <- NA
stack_farmers$hh.maize.maizen.q65[stack_farmers$hh.maize.maizen.q65==999] <- NA
stack_farmers$hh.maize.maizen.q46b[stack_farmers$hh.maize.maizen.q46b==999] <- NA
stack_farmers$hh.maize.maizen.q46b[stack_farmers$hh.maize.maizen.q46b=="n/a"] <- NA
stack_farmers$hh.maize.plot_select_area[stack_farmers$hh.maize.plot_select_area=="n/a"] <- NA
stack_farmers$hh.maize.plot_select_area <- as.numeric(as.character(stack_farmers$hh.maize.plot_select_area))
#make yield variable
stack_farmers$yield_kg <- stack_farmers$hh.maize.maizen.q64*stack_farmers$hh.maize.maizen.q65 #64. bags of maize harvested * 65. kgs in one bag
stack_farmers$yield_kg_per_acre <- stack_farmers$yield_kg/stack_farmers$hh.maize.plot_select_area #area of maize field in acres (particular plot)
#percentage allocated to maize q46b excluded because 454 NA's
#trimming: function for trimming a variable in a dataset - replaces with NA
trim <- function(var, dataset, trim_perc=.05) {
dataset[var][dataset[var] < quantile(dataset[var],c(trim_perc/2,1-(trim_perc/2)), na.rm=T)[1] | dataset[var] > quantile(dataset[var], c(trim_perc/2,1-(trim_perc/2)),na.rm=T)[2] ] <- NA
return(dataset)
}
stack_farmers <- trim("yield_kg_per_acre", stack_farmers)
#standard deviations and means
sd(stack_farmers$yield_kg_per_acre, na.rm=TRUE)
mean(stack_farmers$yield_kg_per_acre, na.rm=TRUE)
###INPUT USE###
#transform
stack_farmers$hh.maize.maizen.q48[stack_farmers$hh.maize.maizen.q48==98] <- NA
stack_farmers$hh.maize.maizen.q48[stack_farmers$hh.maize.maizen.q48=="l"] <- NA #made "other" NA
#make input use variable
stack_farmers$inputuse_binary <- (stack_farmers$hh.maize.maizen.q48 == "a") | (stack_farmers$hh.maize.maizen.q48 == "b")| (stack_farmers$hh.maize.maizen.q48 == "c")| (stack_farmers$hh.maize.maizen.q48 == "d")| (stack_farmers$hh.maize.maizen.q48 == "e")| (stack_farmers$hh.maize.maizen.q48 == "f")| (stack_farmers$hh.maize.maizen.q48 == "g")| (stack_farmers$hh.maize.maizen.q48 == "h")| (stack_farmers$hh.maize.maizen.q48 == "i")| (stack_farmers$hh.maize.maizen.q48 == "j")
#standard deviations and means
sd(stack_farmers$inputuse_binary, na.rm=TRUE)
mean(stack_farmers$inputuse_binary, na.rm=TRUE)
summary(stack_farmers$inputuse_binary, na.rm=TRUE)
rm(list=ls())
#install.packages("randomizr")
#install.packages("fabricatr")
#install.packages("data.table")
#install.packages("mvnfast")
#install.packages("plyr")
#install.packages("sampling")
#install.packages("devtools")
#install.packages("usethis")
library(randomizr)    #randomizr package for complete random assignment
library(fabricatr)
library(data.table)
library(mvnfast)
library(plyr)
library(sampling)
library(usethis)
library(devtools)
library(doParallel)
library(ggplot2)
### this is executed in the /report subdirectory, need to ..
path <- strsplit(getwd(), "/Study design")[[1]]
stack_dealers <- read.csv(paste(path,"stack surveys/data/agro_input_dealers.csv", sep ="/"))
stack_farmers <- read.csv(paste(path,"stack surveys/data/farmers.csv", sep ="/"))
View(stack_farmers)
rm(list=ls())
#install.packages("randomizr")
#install.packages("fabricatr")
#install.packages("data.table")
#install.packages("mvnfast")
#install.packages("plyr")
#install.packages("sampling")
#install.packages("devtools")
#install.packages("usethis")
library(randomizr)    #randomizr package for complete random assignment
library(fabricatr)
library(data.table)
library(mvnfast)
library(plyr)
library(sampling)
library(usethis)
library(devtools)
library(doParallel)
library(ggplot2)
### this is executed in the /report subdirectory, need to ..
path <- strsplit(getwd(), "/Study design")[[1]]
stack_dealers <- read.csv(paste(path,"stack surveys/data/agro_input_dealers.csv", sep ="/"))
stack_farmers <- read.csv(paste(path,"stack surveys/data/farmers.csv", sep ="/"))
summary(stack_dealers$hh.maize.q13)
summary(stack_dealers$hh.maize.q14)
summary(stack_dealers$hh.maize.q15)
